Punctuation will not appear on the input tape.

Let # mean a blank here.

Call a run of 1's a "bundle"... idk.

Initial tape symbol possibilities: 1,0,D,F,m

We may make use of those and other alphanumeric characters.

0's on the tape only separate runs of 1's from other runs of 1's. So this is not given to us: ...1110D

I after init(), tape contents modified

from:
  #1011D1010m011011D(...)F101111#
to:
#1Q1011D1010m011P11D(...)F101111B1#

Note the Q, P(replaces zero before each push of each delta tuple) and B.

Q: current state marker
B: base of stack marker

I thought the left region the tape will hold the current state, to the left of the Q.
Rightmost region marked by B will be with rightmost run of 1's being topmost element:

NOTE: Multiple symbols can be pushed at once, and it follows the convention used in class of pushing
right to left first; the leftmost symbol becomes the top of the stack. So, when doing a push and copying to stack,
copy moving right to left from push bundle(s) in delta tuple, and appending to rightward on stack. Like C++: {*dest++ = *src--;}
Since Reverse(1^N) = 1^N, this works out.

Q and B will be set once in init() and never modified afterwards. When _committing_ to consuming a bundle
from string w, the 1's of that and a potential trailing 0 will be changed to x and stay that for good.

Meanings of other markings (important we need to keep track of these):

* 1->digits [2-9] when doing compares at various stages.
* D->E after a tuple is examined in checking if it matches first state and input bundle (or its cond is m).
* E->G after a successful TryPop(). (maybe?)
* y: reserved for Finish()
* z: reserved for Finish()

A lot of this involves comparing runs of 1's, which involves replacing them with something else.
It might be good to not use the same replace char for every step.




Pseudo code:



[Reject() and AllConsumed() both result in halting]


Main()
{
	Init();
	forever
	{
		[read head is on Q]
		UberFind();
		if (cell=='F') OnF();
		TryPop();
		if (cell==#)
			FailedPopSweep();
		else [read head is on 'P' of delta tuple]
		{
			DoPush();
			OverwriteState();
		}
	}
}
	

["Uber" because this does a lot. It handles both when there are remaining bundles of W,
and when there is only stack left. This means there is a point where some of the stuff it does changes from
never triggering to always triggering and vice versa. This method means we dont need another very similar main-loop type thing
for when all input symbols are consumed, but not sure if that is a good thing.]
UberFind()
{
	Precond:
	Read head is on 'Q'.

	Effect:
	Read head will stop on 'F' if no compatible tuple can be found based on state and w consume condition.
	Else, it changes zero or more D's to E's starting from the left. If more than one is changed, only the rightmost will have its 1's
	changed, any tuples before it will have their 1's restored, though 'E' will stick for all. For the compatible tuple it finds,
	something like [D110111...] will be changed to [E330555...]. Also, the current state 1's will be changed to 2's and the atom of w will be changed to
	444[0|E], if the input atom cond is not lambda and there is a symbol to consume (not all x's).
	The read head is positioned on the rightmost 'E'.
	
	Impl notes:
	Thinking it would seek leftmost untouched 'D', skipping over any tuples that may have failed
	the pop test or tuples that don't match on state and in bundle of w.
}

OnF()
{
	Precond:
	Read head is on is on 'F'.
	
	Effect:
	Moves left, checks to see if all bundles of w are consumed (all x's, no 1's). If not, emits reject and halts.
	If they are, moves to one unit right of left #, on top of first '1' of current state.
}

TryPop()
{
	Precond:
	Called right after non-'F' FindSI(), read head is on 'E' of a delta tuple.
	
	Effect:
	If the pop condition for the tuple is m, skips over the state bundle on the right to 'P'.
	Else, compares the top of stack to the pop cond. ONLY CHANGES 1's, not 0's, P's, or the 'B', etc. In doing this compare,
	it changes the 1's in the bundle of the delta tuple to '6', and top of stack 1's to '7'.
	If there is a match, puts read head on 'P' of the delta tuple, else it goes all the way to a #
	beyond stack top.
	
	[maybe change the 'E' to 'G' if it helps for DoPush(), though if use different digits, probably may not need for that].
}

FailedPopSweep()
{
	Precond:
	Entered after unsuccessful pop, read head is on a # beyond stack top.
	
	Effect:
	Sweeps leftward all the way across the tape changing any digits in [2-9] to 1. Leaves
	everything else as is, importantly the 'E's stay as the are. Puts read head on 'Q' (After bouncing back from left # to clear curretn state from 2's to 1's).
	[sets up precond for top of main loop]
}

DoPush()
{
	Precond:
	TryPop was successful and read head is on P of the delta tuple
	There may be multiple characters to push to the stack so we always want to
	copy characters from right to left to the stack. Starting at 'P' search for the 
	next 'D' or 'F'. Now find previous 0 or 'P', if 0 is found mark it with 'U' and copy the 1s between the
	'U' and 'D' or 'F' or 0 to the top of the stack. Return to the 'U' and replace it 
	with 0 and repeat the process. If P was found, copy the 1s between the P and
	the next 0 or 'D' or 'F' to the top of the stack. 
	When P is found this indicates that it is the last character that needs to be pushed.

	Read head is placed on P 
}

[take care to handle cases when new state is not same length as old, either longer or shorter
it must be that afterwards the area of the tape near Q looks like: ...#111Q...]
OverwriteState()
{

}

[will likely need this]
Finish()
{
	Precond:
	Read head on a '1' to the RIGHT of #, current tape looks like:
	'y' and 'z' do not appear anywhere left of 'B'.

	...#111Q(...)F101101111B...
        ^
	Where the contents of .'s are unknown, but are guaranteed not to have a 'Q', 'F' or 'B'.

	It emits an accept or reject based in if the state to the left of 'Q' is inside the F set.

	to emit Accept:
	   
	...A#...
	   ^
	where (^) is the read position and .'s can be anything.

	To reject, R instead of A.
}


IMPORTANT: Make we need to make TM's that inject our block unmodified from how it will fit into the final product and tests it.


PDA class notes:

Must consume all input as part acceptance criteria.
Condition for halting is zero transitions.



__old stuff:

loop top: put on Q, or left blank?

after all consumed, is like dfa, but "stack is w"
would be like main loop, but only finds instead of findsi.

Main()
{
	Init();
	forever
	{
		[read head is on Q]
		move right while x's;
		if (cell!='1') AllConsumed();//but stack can keep going.
		FindSI();
		if (cell=='F') Reject();
		TryPop();
		if (cell==#)
			FailedPopSweep();
		else [read head is on 'P' of delta tuple]
		{
			DoPush();
			OverwriteState();
		}
	}
}
	

AllConsumed()
{
	code size/duplication?
}
	
[find a tuple with compatible state and input symbol]
FindSI()
{
	Precond:
	Read head is first '1' of next bundle of W.

	Effect:
	If there is no compatible tuple then read head will stop on 'F', and other tape contents do not matter.
	Else, it changes 1 or more D's to E's starting from the left. If more than one is changed, only the rightmost will have its 1's
	changed, any tuples before it will have their 1's restored, though 'E' will stick. For the compatible tuple it finds,
	something like [D110111...] will be changed to [E440555...]. Also, the current state 1's will be changed to 2's and the atom of w will be changed to
	333[0|E], if the input atom cond is not lambda. The read head is positioned on the rightmost 'E'.
	
	Impl notes:
	Thinking it would seek leftmost untouched 'D', skipping over any tuples that may have failed
	the pop test or tuples that don't match on state and in bundle of w.
}

111QcccF1011B		R	Accept
111QcccF111B		A	Accept
111QcccF10111011B	A	Accept
11QcccF11110111B	R	Accept

